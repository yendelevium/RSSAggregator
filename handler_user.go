package main

import (
	"encoding/json"
	"fmt"
	"net/http"
	"time"

	"github.com/Yendelevium/RSSAggregator/internal/database"
	"github.com/google/uuid"
)

// The weird thing abt http handlers in go is that their function signature doesn't change
// But we need to pass the apiConfig to the handler so that we can access the db
// This can be done by making this function a method od apiConfig
func (apiCfg *apiConfig) handlerCreateUser(w http.ResponseWriter, r *http.Request) {
	// This handler needs to take as input a JSON Body, so it should expect some paramaters
	// So let's make a parameters struct, and for now, we just need a name
	type parameters struct {
		Name string `json:"name"`
	}

	// We need to parse the request body into this struct.
	// The json.NewDecoder() function in Go is used to create a new json.Decoder that reads from the provided io.Reader(which is r.Body)
	// This Decoder can then be used to decode JSON data from a stream, such as a file or an HTTP response, into Go data structures.
	decoder := json.NewDecoder(r.Body)

	// Creating an empty params struct
	params := parameters{}

	// We need to decode INTO an instance of a parameters struct. This is done by calling the decode function
	// on the json.Decoder, and passing in a pointer to the datatype we wanna decode the json into
	// This function returns an error, and if it does, it's mostly a client side error, thats y we send status code 400
	err := decoder.Decode(&params)
	if err != nil {
		repsondWithError(w, 400, fmt.Sprintf("Error parsion JSON: %v", err))
		return
	}
	// If all goes well, now we have an access to the name, sent by the user in the json request body
	// in our params struct

	// We can use our database to create a user. CreateUser is the method that sqlc generated for us, on the databse.Queries struct
	// which is stored in apiCfg.DB
	// It accepts a context, and a CreateUserParams, created by sqlc, again

	// In Go, r.Context() is a method on the http.Request type that returns the context.Context associated with the request r.
	// context.Context is a standard way in Go to carry deadlines, cancellation signals, and other request-scoped values across API boundaries and between processes.
	// Basically, context.Context ensures that any timeouts, cancellations, or other context-based operations are respected during the user creation process in the database.
	// This is particularly useful when dealing with operations that might take time (like database queries),
	// as it allows you to respect the lifecycle of the HTTP request (e.g., canceling the operation if the client disconnects).
	user, err := apiCfg.DB.CreateUser(r.Context(), database.CreateUserParams{
		// The id is a uuid, and to use it, we gotta import the package "github.com/google/uuid" , which is a widely used uuid pkg in Go
		// uuid.New() creates a random new uuid. uuid is a bigass string id which is SUPER Random
		// Hence it fits perfectly as a primary key to uniquely identify a record
		// "656dee5d-58e6-4682-8619-8db8af443fd4" a uuid looks like this
		ID: uuid.New(),
		// using time.Now().UTC() as we r creating the record now, and techinacally this means it was also last updated now
		// can just use time.Now(), but this guy wanted it in UTC() so we used that
		CreatedAt: time.Now().UTC(),
		UpdateAt:  time.Now().UTC(),
		// The name is just params.Name, as that's what was passed in the request body
		Name: params.Name,
	})
	if err != nil {
		repsondWithError(w, 400, fmt.Sprintf("Couldn't create user: %v", err))
		return
	}
	// user is a User struct, created by sqlc. We can pass this directly to respondWithJSON

	// But, if u wanna add ur own JSON keys, we made a new User struct, which is the same as the sqlc User,
	// But we just add the json-reflector tags in the struct. Again, no need to create this function if u don't care abt that,
	// just directly pass user. IDT this respondWithJSON is necesssary in the first place, as CreateUser adds the row to our table anyways
	// Ig its just a way to see the results idk
	// Ohh btw, the reason we r doing this whole ass function is coz we cant change the User struct manually, as its generated by sqlc
	// By principle, DON'T TOUCH ANY CODE GENERATED BY SQLC
	respondWithJSON(w, 200, databaseUserToUser(user))
}
