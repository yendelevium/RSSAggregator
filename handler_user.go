package main

import (
	"encoding/json"
	"fmt"
	"net/http"
	"time"

	"github.com/Yendelevium/RSSAggregator/internal/database"
	"github.com/google/uuid"
)

// The weird thing abt http handlers in go is that their function signature doesn't change
// But we need to pass the apiConfig to the handler so that we can access the db
// This can be done by making this function a method od apiConfig
func (apiCfg *apiConfig) handlerCreateUser(w http.ResponseWriter, r *http.Request) {
	// This handler needs to take as input a JSON Body, so it should expect some paramaters
	// So let's make a parameters struct, and for now, we just need a name
	type parameters struct {
		Name string `json:"name"`
	}

	// We need to parse the request body into this struct.
	// The json.NewDecoder() function in Go is used to create a new json.Decoder that reads from the provided io.Reader(which is r.Body)
	// This Decoder can then be used to decode JSON data from a stream, such as a file or an HTTP response, into Go data structures.
	decoder := json.NewDecoder(r.Body)

	// Creating an empty params struct
	params := parameters{}

	// We need to decode INTO an instance of a parameters struct. This is done by calling the decode function
	// on the json.Decoder, and passing in a pointer to the datatype we wanna decode the json into
	// This function returns an error, and if it does, it's mostly a client side error, thats y we send status code 400
	err := decoder.Decode(&params)
	if err != nil {
		repsondWithError(w, 400, fmt.Sprintf("Error parsing JSON: %v", err))
		return
	}
	// If all goes well, now we have an access to the name, sent by the user in the json request body
	// in our params struct

	// We can use our database to create a user. CreateUser is the method that sqlc generated for us, on the databse.Queries struct
	// which is stored in apiCfg.DB
	// It accepts a context, and a CreateUserParams, created by sqlc, again

	// In Go, r.Context() is a method on the http.Request type that returns the context.Context associated with the request r.
	// context.Context is a standard way in Go to carry deadlines, cancellation signals, and other request-scoped values across API boundaries and between processes.
	// Basically, context.Context ensures that any timeouts, cancellations, or other context-based operations are respected during the user creation process in the database.
	// This is particularly useful when dealing with operations that might take time (like database queries),
	// as it allows you to respect the lifecycle of the HTTP request (e.g., canceling the operation if the client disconnects).
	user, err := apiCfg.DB.CreateUser(r.Context(), database.CreateUserParams{
		// The id is a uuid, and to use it, we gotta import the package "github.com/google/uuid" , which is a widely used uuid pkg in Go
		// uuid.New() creates a random new uuid. uuid is a bigass string id which is SUPER Random
		// Hence it fits perfectly as a primary key to uniquely identify a record
		// "656dee5d-58e6-4682-8619-8db8af443fd4" a uuid looks like this
		ID: uuid.New(),
		// using time.Now().UTC() as we r creating the record now, and techinacally this means it was also last updated now
		// can just use time.Now(), but this guy wanted it in UTC() so we used that
		CreatedAt: time.Now().UTC(),
		UpdateAt:  time.Now().UTC(),
		// The name is just params.Name, as that's what was passed in the request body
		Name: params.Name,
	})
	if err != nil {
		repsondWithError(w, 400, fmt.Sprintf("Couldn't create user: %v", err))
		return
	}
	// user is a User struct, created by sqlc. We can pass this directly to respondWithJSON

	// But, if u wanna add ur own JSON keys, we made a new User struct, which is the same as the sqlc User,
	// But we just add the json-reflector tags in the struct. Again, no need to create this function if u don't care abt that,
	// just directly pass user. IDT this respondWithJSON is necesssary in the first place, as CreateUser adds the row to our table anyways
	// Ig its just a way to see the results idk
	// Ohh btw, the reason we r doing this whole ass function is coz we cant change the User struct manually, as its generated by sqlc
	// By principle, DON'T TOUCH ANY CODE GENERATED BY SQLC

	// Creating a user is a 201 code, coz 201 is like a "created" code so it's a little more
	// correct than compared to just sending 200, but u won't really have a problem if it's 200 either
	respondWithJSON(w, 201, databaseUserToUser(user))
}

// We don't need to create a new handlerCreateUser, as the APIKey is handled by SQL itself
// But we do need to crete a handler to get a user
// This, will actually be an authenticated endpoint. So it will look very different form the handlerCreateUser function
// To create a new user, u don't need an apikey. But to get details abt ur user, u need to give us an apikey first
// This is why it's an "authenticated" endpoint, ur checking the apikey basically
// This is not gonna be the only authenticated endpoint, so we are going to abstract the logic for getting a user using their
// apilkey to another package called auth, in the internal directory.
func (apiCfg *apiConfig) handlerGetUser(w http.ResponseWriter, r *http.Request, user database.User) {

	// The middleware handles getting the user from the APIKey
	// We just need to respond abt the user details with JSON
	respondWithJSON(w, 200, databaseUserToUser(user))
}

// We need a way for the user to access all the posts from the feeds the user is following
// This will also be an autheticated endpoint, as we need the feeds that the user follows in order to get the posts from those feeds
func (apiCfg *apiConfig) handlerGetPostsForUser(w http.ResponseWriter, r *http.Request, user database.User) {
	posts, err := apiCfg.DB.GetPostsForUser(r.Context(), database.GetPostsForUserParams{
		UserID: user.ID,
		Limit:  int32(10),
	})
	if err != nil {
		repsondWithError(w, 400, fmt.Sprintf("Couldn't get posts: %v", err))
		return
	}
	respondWithJSON(w, 200, databasePostsToPosts(posts))
}
